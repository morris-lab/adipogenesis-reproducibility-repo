---
title: "P32 Naive Processed Data Analysis"
author: "Emily Butka"
date: "2023-07-26"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(Seurat)
library(ggplot2)
library(scclusteval)
library(grid)
```

This notebook contains code used to integrate 4 biological replicates, quality control, and analyze P32 naive data following alignment. Code for all panels from Figure 2, Figure 3A-B, and Supplementary Figure 5 is outlined here.

## Load processed data

Raw data is processed in the preceeding notebook. Here, we will use the processed data for further analysis. This can be found at: https://figshare.com/s/396c5f4ebd3c23d20094

```{r load-data}
p32 <- readRDS("~/Downloads/p32_naive_processed.rds")
```

## Color palettes

```{r}
colpal12 <- c("#FFC33B", "#FF6E3A", "#E20134", "#9F0162", "#FFB2FD", "#00C2F9", "#008DF9", "#8400CD", "#00FCCF", "#FF5AAF", "#009F81", "gray")
```

```{r}
colpal6 <- c("#211E71", "#009F81", "#FF5AAF", "#741112", "#FFC02D", "gray")
```

```{r}
colpal2_pink_blue <- c("#E75F62", "#232380")
```

## Prelim plots

```{r}
p2b <- DimPlot(p32, label = T, label.size = 7, raster = F) + NoLegend() + theme(axis.text = element_blank(), axis.ticks = element_blank(), axis.line = element_blank(), axis.title = element_blank(), text = element_text(size = 8, family='Helvetica'), plot.margin = margin(0, 0, 0, 0)) 
p2b
```

```{r}
p2c <- DimPlot(p32, cells.highlight = list("Progenitors" = colnames(p32)[which(p32$celltag == "v2")], "Preadipocytes" = colnames(p32)[which(p32$celltag == "v1")]), cols.highlight = c("#232380", "#E75F62"), sizes.highlight = 0.5) + theme(axis.text = element_blank(), axis.ticks = element_blank(), axis.line = element_blank(), axis.title = element_blank(), text = element_text(size = 8), plot.margin = margin(0, 0, 0, 0), legend.position = "bottom")
p2c
```

```{r}
p3al <- FeaturePlot(p32, features = "Sox9")
p3ar <- FeaturePlot(p32, features = "Pparg")
p3al
p3ar
```

```{r}
p3b <- VlnPlot(p32, features = "Sox9", group.by = "celltag", pt.size = 0) + scale_fill_manual(values = c("gray", colpal2_pink_blue)) + theme(plot.title = element_blank()) + scale_x_discrete(labels = c("None", "Preadipocyte", "Progenitor")) + NoLegend()
p3b
```

```{r}
s5a <- FeaturePlot(p32, features = "Cebpa")
s5a
```

```{r}
# Mark cells that have GFP > 0 OR a CellTag as "TRANSPLANT"
p32$is_transplant <- TRUE
p32$is_transplant[which(p32@assays$RNA@counts["GFP.CDS", ] == 0 & p32$celltag == "none")] <- FALSE
#table(p32$is_transplant)
```

```{r}
umap.embedding <- p32@reductions$umap@cell.embeddings
transplant.embedding <- as.data.frame(umap.embedding[which(p32$is_transplant), ])
```

```{r}
s5b <- ggplot(transplant.embedding, aes(x = UMAP_1, y = UMAP_2)) +
  stat_density_2d(aes(fill = stat(density)), geom="raster", contour = FALSE) +
  #scale_fill_viridis(option = "H") +
  #scale_fill_gradient(low = "white", high = "darkgreen") + 
  scale_fill_gradientn(colors = c("white", magma(5)[2:5])) +
  geom_point(alpha = 0.2, size = 0.2, color = "#FCFDBF") + theme_classic() + theme(axis.line = element_blank(), axis.text = element_blank(), axis.ticks = element_blank(), axis.title = element_blank(), plot.margin = unit(c(0,0,0,0), "cm"), legend.position = "bottom")
s5b + theme(legend.position = "bottom")
#ls5b <- g_legend(s5b)
#s5b <- grid.arrange(p3c + theme(legend.position = "none"), ls5b, nrow = 2, heights = unit(c(2, 1), c("in", "in")))
#p3cl
```

## Capybara with P21 new classification reference

### Run Capybara using custom reference as defined by cell types in P21 dataset

Code and workflow described at https://github.com/morris-lab/Capybara. We did not perform tissue-level classification (Step 1); rather, a high-resolution custom reference was generated and continuous identity measured (Step 2) followed by discrete cell type classification and multiple identity scoring (Step 3).

Custom code to extract hybrid IDs and mean p-values for assignments is as follows, using data frames `bin.count` and `perc.list` described in Capybara workflow:

```{r}
# hybrids
bin.count.rowsums <- apply(bin.count, 1, sum)
rownames(bin.count)[which(bin.count.rowsums > 1)]
bin.count.greaterthan1 <- apply(bin.count[which(bin.count.rowsums > 1), ], c(1, 2), function(x) {x > 0})
multi.celltypes <- apply(bin.count.greaterthan1, 1, function(x) {print(colnames(bin.count.greaterthan1)[x])})

hybrids <- c()
for(i in 1:length(multi.celltypes)) {
  #print(multi.celltypes[i])
  hybrids <- c(hybrids, paste(multi.celltypes[[i]], collapse = "-"))
}

hybrids <- gsub("frxn_cell.type_", "", hybrids)

# p-values for classifications
pval_avg_mat <- data.frame()
for(i in 1:length(perc.list)) {
  pval_avg_mat <- rbind(pval_avg_mat, apply(perc.list[[i]][[1]], 2, mean))
  rownames(pval_avg_mat)[i] <- names(perc.list[[i]])
}
colnames(pval_avg_mat) <- names(apply(perc.list[[1]][[1]], 2, mean))
```

Classifications, hybrids, p-values, and identity fractions imported to P32 Seurat object as `capy_new_class`, `capy_new_class_hybrid`, `capy_pval_xxx`, and `capy_frxn_xxx`, respectively. This information is stored in `p32_naive_processed.rds` on Figshare.

### Figures and visualizations of Capybara data

```{r}
p32$capy_new_class_short <- gsub("_", " ", p32$capy_new_class_short)
p32$capy_new_class_short <- factor(p32$capy_new_class_short, levels = c("Int prog", "Trans int prog", "Imm preadip", "Comm preadip", "Multi ID", "Unknown"))
```

```{r}
g_legend <- function(a.gplot){
  tmp <- ggplot_gtable(ggplot_build(a.gplot))
  leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  legend <- tmp$grobs[[leg]]
  return(legend)}
```

```{r}
p2d <- DimPlot(p32, group.by = "capy_new_class_short", cols = colpal6) + theme(axis.text = element_blank(), axis.ticks = element_blank(), axis.line = element_blank(), axis.title = element_blank(), plot.title = element_blank(), plot.margin = margin(0, 0, 0, 0), legend.position = "bottom")
l2d <- g_legend(p2d)
p2d + NoLegend()
p2d <- grid.arrange(p2d + theme(legend.position = "none"), l2d, nrow = 2, heights = unit(c(2, 1), c("in", "in")))
p2d
```

```{r}
ctcapy <- data.frame(table(p32$celltag, p32$capy_new_class_short))
p2el <- ggplot(ctcapy[ctcapy$Var1 == "v2", ], aes(x="", y=Freq, fill=Var2)) + geom_bar(stat="identity", width=1, color="white") + theme_void() + ggtitle("Dpp4 CellTagged cells") + theme(legend.position="none", text = element_text(size = 8), plot.title = element_text(hjust = 0.5)) + labs(fill = "Cell type") + scale_fill_manual(name = "Cell type", values = colpal6)
p2er <- ggplot(ctcapy[ctcapy$Var1 == "v1", ], aes(x="", y=Freq, fill=Var2)) + geom_bar(stat="identity", width=1, color="white") + theme_void() + ggtitle("Cd9 CellTagged cells") + scale_fill_manual(name = "Cell type", values = colpal6) + theme(text = element_text(size = 8), legend.position = "none", plot.title = element_text(hjust = 0.5))
p2e <- p2el + p2er
p2e
```

### Host vs. transplant

```{r}
# Mark cells that have GFP > 0 OR a CellTag as "TRANSPLANT"
p32$celltag_origin <- p32$celltag
p32$celltag_origin[which(p32@assays$RNA@counts["GFP.CDS", ] == 0 & p32$celltag == "none")] <- "None-Host"
p32$celltag_origin[which(p32@assays$RNA@counts["GFP.CDS", ] > 0 & p32$celltag == "none")] <- "None-Transplant"
```

#### Remove transplant cells, re-cluster, and compare clusters to original host-transplant co-embedding

```{r}
p32 <- FindNeighbors(p32, return.neighbor = T)
```

```{r}
DefaultAssay(p32) <- "integrated"
```

```{r}
# New clusters and embedding of host cells only
p32_sub <- p32[, which(p32$celltag_origin == "None-Host")]
```

```{r}
# Clusters and embedding generated with host and transplant cells
p32_sub2 <- p32[, which(p32$celltag_origin == "None-Host")]
```

```{r}
p32_sub <- ScaleData(p32_sub)
p32_sub <- FindVariableFeatures(p32_sub)
p32_sub <- RunPCA(p32_sub)
p32_sub <- RunUMAP(p32_sub, dims = 1:10)
p32_sub <- FindNeighbors(p32_sub)
p32_sub <- FindClusters(p32_sub)
p32_sub <- FindNeighbors(p32_sub, return.neighbor = T)
```

```{r}
DimPlot(p32_sub2, label = TRUE, label.size = 7) + NoLegend()
```

```{r}
DimPlot(p32_sub, label = TRUE, label.size = 7) + NoLegend()
```

```{r}
p32_sub2 <- FindNeighbors(p32_sub2, reduction = "umap", dims = 1:2, k.param = 20, return.neighbor = TRUE)
```

```{r}
nndistdf <- data.frame(p32_sub2@neighbors$integrated.nn@nn.dist, row.names = p32_sub2@neighbors$integrated.nn@cell.names)
```

```{r}
nndistdf_mean <- apply(nndistdf, 1, mean)
```

#### Now find distances and calculate mean for reclustered host data with same cells

```{r}
nncells_orig <- data.frame(p32_sub2@neighbors$integrated.nn@nn.idx, row.names = p32_sub2@neighbors$integrated.nn@cell.names)
```

```{r}
umap_new <- p32_sub@reductions$umap@cell.embeddings
```

```{r}
euclidean <- function(a, b) sqrt(sum((a - b)^2))
```

```{r}
nndistdf2 <- data.frame()
for(j in 1:dim(nncells_orig)[1]) {
  row <- c()
  for(i in 1:dim(nncells_orig)[2]) {
    row <- c(row, euclidean(umap_new[rownames(nncells_orig)[j], ], umap_new[nncells_orig[j, i], ]))
  }
  #print(row)
  nndistdf2 <- rbind(nndistdf2, row)
}
```

```{r}
nndistdf2_mean <- apply(nndistdf2, 1, mean)
```

```{r}
nncells_random <- data.frame()
for(j in 1:dim(nncells_orig)[1]) {
  row <- sample.int(dim(nncells_orig)[1], 20, replace = FALSE)
  nncells_random <- rbind(nncells_random, row)
}
rownames(nncells_random) <- p32_sub2@neighbors$integrated.nn@cell.names
```

```{r}
nndistdf_random <- data.frame()
for(j in 1:dim(nncells_orig)[1]) {
  row <- c()
  for(i in 1:dim(nncells_random)[2]) {
    row <- c(row, euclidean(umap_new[rownames(nncells_random)[j], ], umap_new[nncells_random[j, i], ]))
  }
  #print(row)
  nndistdf_random <- rbind(nndistdf_random, row)
}
```

```{r}
nndistdf_random_mean <- apply(nndistdf_random, 1, mean)
```

```{r}
nncells_random_in_clust <- data.frame()
for(j in 1:dim(nncells_orig)[1]) {
  clust <- p32_sub$seurat_clusters[rownames(nncells_orig)[j]]
  cells_in_clust <- c(1:dim(nncells_orig)[1])[which(p32_sub$seurat_clusters == clust)]
  row <- cells_in_clust[sample.int(length(cells_in_clust), 20, replace = FALSE)]
  nncells_random_in_clust <- rbind(nncells_random_in_clust, row)
}
rownames(nncells_random_in_clust) <- p32_sub2@neighbors$integrated.nn@cell.names
```

```{r}
nndistdf_random_in_clust <- data.frame()
for(j in 1:dim(nncells_orig)[1]) {
  row <- c()
  for(i in 1:dim(nncells_random_in_clust)[2]) {
    row <- c(row, euclidean(umap_new[rownames(nncells_random_in_clust)[j], ], umap_new[nncells_random_in_clust[j, i], ]))
  }
  #print(row)
  nndistdf_random_in_clust <- rbind(nndistdf_random_in_clust, row)
}
```

```{r}
nndistdf_random_in_clust_mean <- apply(nndistdf_random_in_clust, 1, mean)
```

```{r}
nndistdf2_own <- data.frame(p32_sub@neighbors$integrated.nn@nn.dist, row.names = p32_sub@neighbors$integrated.nn@cell.names)
```

```{r}
nndistdf2_own_mean <- apply(nndistdf2_own, 1, mean)
```

```{r}
dists <- data.frame("embedding" = c(rep("Original", dim(nncells_orig)[1]), rep("Reclustered", dim(nncells_orig)[1]), rep("Reclustered_own_20nn", dim(nncells_orig)[1]), rep("Random", dim(nncells_orig)[1]), rep("Random_in_clust", dim(nncells_orig)[1])),
                    "distance" = c(nndistdf_mean, nndistdf2_mean, nndistdf2_own_mean, nndistdf_random_mean, nndistdf_random_in_clust_mean))
```

```{r}
dists$embedding <- factor(dists$embedding, levels = c("Original", "Reclustered", "Reclustered_own_20nn", "Random", "Random_in_clust"))
```

```{r}
s5c <- ggplot(dists, aes(x = gsub("_", " ", embedding), y = distance)) + geom_boxplot() + theme_classic() + labs(x = "Embedding", y = "Distance")
s5c
```

### Biological replicate

## Jaccard analysis associating cell type and louvain cluster

```{r}
p32$cp_ip <- ifelse(p32$capy_new_class_short == "Comm preadip", "comm_preadip", ifelse(p32$capy_new_class_short == "Int prog", "int_prog", NA))
jacc <- data.frame(PairWiseJaccardSets(p32$seurat_clusters, p32$cp_ip))
```

```{r}
numip <- table(p32$capy_new_class_short)["Int prog"]
numcp <- table(p32$capy_new_class_short)["Comm preadip"] 
numna <- sum(table(p32$capy_new_class_short)) - table(p32$capy_new_class_short)["Int prog"] - table(p32$capy_new_class_short)["Comm preadip"] 
p32$cp_ip_random <- sample(c(rep("int_prog", numip), rep("comm_preadip", numcp), rep(NA, numna)))
jacc_rand <- data.frame(PairWiseJaccardSets(p32$seurat_clusters, p32$cp_ip_random))
jacc_rand$rep <- 1
jacc_rand$cluster <- 0:13
```

```{r}
for(i in 2:1000) {
  p32$cp_ip_random <- sample(c(rep("int_prog", numip), rep("comm_preadip", numcp), rep(NA, numna)))
  jacc_rand_intermed <- data.frame(PairWiseJaccardSets(p32$seurat_clusters, p32$cp_ip_random))
  jacc_rand_intermed$rep <- i
  jacc_rand_intermed$cluster <- 0:13
  jacc_rand <- rbind(jacc_rand, jacc_rand_intermed)
}
```

```{r}
mzscores <- c()
for(i in 1:14) {
  mzip <- 0.6745 * (jacc$int_prog[i] - median(jacc_rand$int_prog[jacc_rand$cluster == i - 1])) / mad(jacc_rand$int_prog[jacc_rand$cluster == i - 1])
  mzcp <- 0.6745 * (jacc$comm_preadip[i] - median(jacc_rand$comm_preadip[jacc_rand$cluster == i - 1])) / mad(jacc_rand$comm_preadip[jacc_rand$cluster == i - 1])
  mzscores <- c(mzscores, mzip, mzcp)
}
```

```{r}
zdf <- data.frame(mzscore = mzscores, cell_type = rep(c("int_prog", "comm_preadip"), 14), cluster = c(0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13))
```

```{r}
p2f <- ggplot(zdf, aes(x = cluster, y = cell_type, fill = mzscore)) + 
  geom_tile(color = "white",
            lwd = 0.5,
            linetype = 1) + geom_text(aes(label = round(mzscore))) + theme_classic() + theme(axis.line = element_blank(), legend.position = "bottom", text = element_text(size = 8)) +
  scale_y_discrete("Cell type") +
  scale_x_continuous("Cluster", labels = as.character(seq(0,13)), breaks = seq(0,13)) +
  #scale_x_discrete("Cluster") + coord_fixed() +
  scale_fill_gradient2(
        low = "#053061", mid = "#F7F7F7", high = "#67001F", midpoint = 0)
p2f
```

## Permutation testing

```{r}
df2g <- data.frame(UMAP_1 = p32@reductions$umap@cell.embeddings[, 1], UMAP_2 = p32@reductions$umap@cell.embeddings[, 2], enriched = p32$enriched)
df2g <- rbind(df2g, data.frame(UMAP_1 = p32@reductions$umap@cell.embeddings[which(p32$enriched == "Both"), 1], UMAP_2 = p32@reductions$umap@cell.embeddings[which(p32$enriched == "Both"), 2], enriched = rep("V1", table(p32$enriched)["Both"])))
df2g$enriched <- gsub("Both", "V2", df2g$enriched)
df2g2 <- na.omit(df2g)
```

```{r}
p2g <- DimPlot(p32, label = T, label.size = 7, cols = c(rep("gray", 14), colpal2_pink_blue)) + theme(axis.text = element_blank(), axis.ticks = element_blank(), axis.line = element_blank(), axis.title = element_blank(), plot.margin = margin(0, 0, 0, 0)) + NoLegend() + geom_density_2d(data = df2g2, aes(x = UMAP_1, y = UMAP_2, color = enriched))
p2g
```

```{r}
p3h <- DimPlot(adi_merged, cells.highlight = list("Dpp4" = colnames(adi_merged)[which(adi_merged$enriched == "V2")], "Cd9" = colnames(adi_merged)[which(adi_merged$enriched == "V1")], "Both" = colnames(adi_merged)[which(adi_merged$enriched == "Both")]), cols.highlight = c("#232380", "#E75F62", "#1DD3B0")) + theme(axis.text = element_blank(), axis.ticks = element_blank(), axis.line = element_blank(), axis.title = element_blank(), text = element_text(size = 8), plot.margin = margin(0, 0, 0, 0), legend.position = "bottom")
p3h + theme(legend.position = "none")
l3h <- g_legend(p3h)
p3hl <- grid.arrange(p3h + theme(legend.position = "none"), l3h, nrow = 2, heights = unit(c(2, 1), c("in", "in")))
p3hl
ggsave("~/OneDrive/MorrisLab/Guillermo_project/manuscript/plots/fig_3_h.pdf", plot = p3hl, height = 3, width = 3, units = "in", dpi = 600)
```













